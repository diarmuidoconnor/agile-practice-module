## Pods.

In `k8s-basics` create a file named `nginx-pod.yaml`:
~~~
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod1
  labels:
    team: integration
    app: todo
spec:
  containers:
  - name: nginx
    image: nginx:latest
    ports:
    - containerPort: 80
~~~
The manifest declares a single-container pod that uses the NGINX web server. Ccreate the pod resource in the cluster:
~~~
$ oc apply -f nginx-pod.yaml 
~~~
Check the result:
~~~
$ oc get pods -o wide            
NAME         READY   STATUS    RESTARTS   AGE     IP            NODE      NOMINATED NODE   READINESS GATES
nginx-pod1   1/1     Running   0          3m29s   10.129.2.57   worker2   <none>           <none>
~~~
Use port-forwarding to enable a web client communicate with the web server:
~~~
$ oc port-forward nginx-pod1  3005:80                 
Forwarding from 127.0.0.1:3005 -> 80
Forwarding from [::1]:3005 -> 80
~~~
Open a browser tab at http://localhost:3006/


In VS Code, open a second integrated terminal and check the log output from the pod container:
~~~
‚ùØ oc logs nginx-pod1 
~~~
The last entry in the response should confirm the request from the browser, i.e. GET / HTTP/1.1.

We can open a terminal session inside the contaiiner:
~~~
$ oc exec -it nginx-pod1  -- /bin/sh
~~~
At the container prompt, type the following command sequence:
~~~
ls
cd /usr/share/nginx/html
ls
cat index.html     
echo "<b>I added a new line ....</b>" >> index.html 
~~~
We added a new line to the end of the default NGINX home page. Assuming the port-forwarding to the container is still active, refresh the browser to confirm the page change. 

Interrupt the port-forwarding command.

Commit the work so far:
~~~
$ git add -A
$ git commit -m "Creating simple single-container pod."
~~~

### ReplicaSets.
Creating multiple copies of a pod, termed replicasets, distributed across the worker nodes of a cluster inproves app availability. 

Create a new file called `httpd-replica.yaml`:
~~~
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: httpd-replica
spec:
  replicas: 2
  selector:
     matchLabels:
        app: httpd
  template:
    metadata:
      name: httpd-pod
      labels:
        app: httpd
    spec:
      containers:
      - name: httpd-pod1
        image: httpd:latest
        ports:
        - containerPort: 80
~~~
This manifest declares a replicaset for two copies of a template that defines a single-container pod with the Apache Web Server (httpd image). Create the resources:
~~~
$ oc apply -f httpd-replica.yaml
$ oc get rs        (rs = replicaset )  
$ oc get po        (po = pods )              
~~~

Test one of the pods with port forwarding:
~~~
$ oc port-forward httpd-replica-bkxg7  3000:80    (Your pod name will be different)
~~~
Find the IP addresses of all your pods:
~~~
$ oc get pods -o wide            
~~~
Because all pods are in the same cluster (but on different nodes, perhaps), they can communicate using IP addresses. Try the following sequence:
~~~
$ oc exec -it httpd-replica-bkxg7  -- /bin/sh    (Use your first HTTPD pod name)
# apt-get -y update
# apt-get -y install curl     (Some images includes curl, but HTTPD does not)
#
# curl 10.130.0.124:80   (Use the IP address of your second HTTPD pod)
<html><body><h1>It works!</h1></body></html>
#
# curl 10.129.2.66:80   (Use the IP address of your NGINX pod)
<!DOCTYPE html>
<html>
. . . . NGINX home page . . . .
</html>
#
~~~

Commit the work so far:
~~~
$ git add -A
$ git commit -m "Creating simple replicaset."
~~~
__Cleanup:__ Delete the current pods:
~~~
$ oc delete pods nginx-pod1
$ oc delete -f httpd-replica.yaml     (Delete every resource created by a manifest)
~~~

### Deployments.

In a agile development environment, utomation of application rollout and rollback is essential. Kubernetes Deployments support these requirements.

We will create a 