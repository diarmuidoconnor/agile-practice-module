## Custom Docker images 

To fully containerise our multi-component application, we must __dockerize__ the custom web app. 

### Build.
In VS Code, create a new file in the base folder (one level above the app folder) called `Dockerfile`, and add the following set of instructions:
~~~
FROM node:20-alpine

ENV MONGO_USER='admin' \
     MONGO_PASS='' \
     MONGO_HOST='' \
     MONGO_PORT=27017 \
     PORT=3000

EXPOSE 3000

RUN mkdir -p /home/app
WORKDIR /home/app

COPY ./app .
RUN npm install

CMD ["node", "server.js"]
~~~
Notice that the more sensitive environment variables are empty, e.g. MONGO_PASS. We specify these at runtime for security reasons. The COPY directive copies all the files/folders in the host's `./app` folder in to the image's `/home/app` directory, __except__ for any file/folder named in the `.dockerignore` file. 


Open an integrated terminal in VS Code and __build a Docker image__ of the app as follows:
~~~bash
$ docker build -t profile-app:1.0  .      (The . at the end is important!)
~~~
Check the list of local images to confirm the presence of profile-app:
~~~bash
$ docker images
~~~

### Run.

We can now start all the components that make up this application's architecture as containers:
~~~bash
$ docker rm -vf $(docker ps -aq)    (Remove all current containers)  
$  docker run -d   \
   --name mongoDB  \
   -e MONGO_INITDB_ROOT_USERNAME=admin \
   -e MONGO_INITDB_ROOT_PASSWORD=secret \
 mongo:8.0-rc     
$ docker run -d  \
   --name mongo-express  \
   -p 8081:8081 \
   -e ME_CONFIG_MONGODB_ADMINUSERNAME=admin \
   -e ME_CONFIG_MONGODB_ADMINPASSWORD=secret   \
   -e ME_CONFIG_MONGODB_SERVER=mongoDB   \
mongo-express:1.0-20-alpine3.19
$ docker run -d  \
   --name profileapp  \
   -p 3000:3000 \
   -e MONGO_PASS=secret \
   -e MONGO_HOST=mongoDB \
 profile-app:1.0
$ docker ps        (There should be three containers running)
~~~
Notice that we are no longer using port forwarding for the MongoDB server container; it's not required and ensures better isolation of the database. 
 
Confirm the entire application is working by opening one browser tab at http://localhost:3000/ (the profile app) and a second browser tab at http://localhost:8081/ (the Mongo Express app). In the Profile app tab, add your user profile and then use the Mongo Express tab to verify that the data is in the database.

Commit this work:
~~~
$ git commit -m "Build Docker image."
$ git push origin main
~~~

### The container.

The profile app container we created above contains the Profile app code. Check this as follows:
~~~bash
$  docker exec -it profileapp   /bin/sh
/home/app # ls 
. . . . . the response lists all the same files as . . . .
. . . . . the project in VS Code, EXCEPT the .env file . . . . 

/home/app # env     (List all environment variables)
MONGO_HOST=mongoDB
MONGO_USER=admin
NODE_VERSION=20.14.0
HOSTNAME=c260bdcba506
PORT=3000
HOME=/root
MONGO_PORT=27017
MONGO_DB=
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
MONGO_PASS=secret
PWD=/home/app

/home/app # exit
~~~
Some of the environment variables listed above were initialised at container __runtime__ using the -e option, e.g., MONGO_PASS and MONGO_HOST. Some other variables were initialised at image __build time__ from the Dockerfile, e.g., MONGO_USER, MONGO_PORT, and PORT.

In the`db/index,js` file, there is a console log statement that outputs the connection string used to communicate with the database server:
~~~js
let mongo_url = `mongodb://${process.env.MONGO_USER}:${process.env.MONGO_PASS}@${process.env.MONGO_HOST}:${process.env.MONGO_PORT}`;
console.log(mongo_url)
~~~
To see the statement's output, use the following command:
~~~bash
$ docker logs profileapp
~~~
The logs command is handy when debugging. You should understand the structure of this connection string!!

### Publish and Share.

To publish your image on Docker Hub, navigate to your account in a browser tab, select the Repositories tab (located at the top of the page), and click the Create Repository button. Name the repo __profile-app__ and set the visibility to __Public__. In VS Code, type the commands:
~~~bash
$ docker tag profile-app:1.0  [your_hub_username]/profile-app:1.0
e.g. docker tag profile-app:1.0 doconnor/profile-app:1.0
$ docker images
~~~
The tag command creates an alias for an image. Here, the alias is in a form that's suitable for pushing to Docker Hub. Type the following commands:
~~~bash
$ docker login
$ docker push [your_hub_username]/profile-app:1.0
e.g. docker push doconnor/profile-app:1.0
~~~ 
In the browser, check your Hub account to verify the image is there.

### Exercise 1.

First, delete the profile app container:
~~~bash
$ docker stop profileapp
$ docker rm profileapp
~~~

Suppose we want the profile app to be listening on port 8080 instead of 3000, Make the necessary change(s), rebuild the image, using a version number of 1.1. Verify it works.

Commit this work:
~~~
$ git commit -m "Change Profile app port."
$ git push origin main
~~~

Publish the new image on your Docker Hub account.

### Exercise 2.

Confirm that the container running the profile app can communicate (ping) with the database container. Recall how we did this in the Docker Networks lab.

### Exercise 3.

Currently, in the browser, the web page of the profile app displays a fixed picture (of a dog) at the top. However, there are other pictures in the `/images` folder. A more flexible solution would be to use an environment variable at container runtime to specify which picture to use, i.e. 
~~~
$ docker run . . . -e IMAGE=profile-2 . . . . 
~~~
__You are required__ to implement this requirement. 

Commit this work:
~~~
$ git commit -m "Main page picture configurable."
$ git push origin main
~~~

Publish the updated profile app image to your Docker Hub account, using a version number of 1.2.

[Hint: The `server.js` file controls the addition of a picture to the web page. ]
