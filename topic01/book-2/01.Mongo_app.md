## Demo 1 Setup.

From the command line, type the following command:
~~~bash
$ docker pull mongo:8.0-rc.       (An image containing the MongoDB database server)
$ docker pull mongo-express:1.0-20-alpine3.19.       (An image containing a web-based MongoDB admin application)
$ docker network create mongo-network
~~~
The last command creates a virtual network interface and connects it to the host network. The new network's name is arbitrary. To confirm the creation, type the command:
~~~bash
$ docker network ls
~~~
All containers are automatically attached to a network. The default network is named bridge and was created by Docker on startup. The new custom network interface (mongo-network) has a driver/type of bridge, which is the same as the default's type. Other types include overlay, host, macvlan, etc. Each bridge network is assigned a subnet range and a gateway to the host. Each container added to a bridge network is assigned an IP address from the subnet range - this is performed by a DHCP server included with Docker. Type the command:
~~~bash
$ docker network inspect mongo-network
~~~
Notice the config section of the JSON response:
~~~json
    "Config": [
        {
            "Subnet": "172.17.0.0/16",
            "Gateway": "172.17.0.1"
        }
    ]
~~~
Use the same command for the default bridge network interface.

Start a container for the MongoDB image:
~~~bash
$ docker run -d --net mongo-network \
    --name mongoDB  \
    -p 27017:27017 \
    -e MONGO_INITDB_ROOT_USERNAME=admin \
    -e MONGO_INITDB_ROOT_PASSWORD=secret \
 mongo:8.0-rc
~~~
Points to note:
1. We can control the initialization of a container's environment variables using the -e option, as illustrated above. The variable names depend on the imagre's requirements, and these are documented on Docker Hub. For example, go to [this page][mongov] and scroll to the Environment Variables section for details on the MongoD B image. Some image variables are optional and have default values.
1. We are attaching our MongoDB container to the mongo-network virtual network interface. Docker creates a virtual ethernet interface for the container and links it to the virtual bridge/switch. Other container that wants to communicate with this database must be on the same network.
1. Port 27017 is the default MongoDB port for client communication. Using Docker's port forwarding facility, we are mapping the container's port 27017 to the host port 27017. This will allow non-containerized applications to interact with the database - see later.

Type the following command:
~~~bash
 $ docker run -d --network mongo-network \
      --name mongo-express  \
      -p 8081:8081 \
      -e ME_CONFIG_MONGODB_ADMINUSERNAME=admin \
      -e ME_CONFIG_MONGODB_ADMINPASSWORD=secret   \
      -e ME_CONFIG_MONGODB_SERVER=mongodb   \
mongo-express:1.0-20-alpine3.19
~~~
Points to note:

1. We are using the same virtual network for both containers because the mongo-express web app needs to connect to the Mongo database.
1. The ME_CONFIG_MONGODB_SERVER environment variable must be set to the __name of the container__ hosting our database, i.e. mongoDB. Custom bridge networks (e.g. mongo-network) support DNS name resolution; this allows containers inside the sa,e network to use container names instead of IP address to communicate. 
1. The ME_CONFIG_MONGODB_ADMINUSERNAME and ME_CONFIG_MONGODB_ADMINPASSWORD must match the credentials used by the MongoDB container. 
1. The mongo-express web application is listening on port 8081 for HTTP requests. We are mapping this container port to the equivilant one on the host so we can access it from a web browser client.

To access the Mong-Express admin web application hosted by the second container, open a new browser tab at http://localhost:8081/. User the credentials *admin* (username) and *pass* (password) to login. The browser lists the databases managed by the MongoDB server running inside the first container. 

We want to add a new database to the server using the web admin tool. In the browser, locate the text box at the top-right, enter the name `user-account` and click the Create Database button. 

### Networking.

Concerning the status of the mongo-network network, type the command:
~~~bash
$ docker network inspect mongo-network
~~~
Notice the containers section of the JSON response:
~~~json
       "Containers": {
            "4421b2d2f2f1ae8f7bbad777f308a5c2b718a59db06531488d567083004a5ea5": {
                "Name": "mongo-express",
                "EndpointID": "6833c54b563974cf32f62f4308bac6d500ac40078cd4425384a3b5834a8c8d86",
                "MacAddress": "02:42:ac:12:00:03",
                "IPv4Address": "172.18.0.3/16",
                "IPv6Address": ""
            },
            "5010babf9a8dbdc28592a16e270acd6858347ce9f096009b5a30edae87bbc8a4": {
                "Name": "mongoDB",
                "EndpointID": "6bbd0907ca24aab5be8bbc93559782d35c04ae5566155d0116e4edd569061cd6",
                "MacAddress": "02:42:ac:12:00:02",
                "IPv4Address": "172.18.0.2/16",
                "IPv6Address": ""
            }
        },
~~~
It shows the IP address assigned to each container by the DHCP server. The MacAddress property corresponds to the virtual ethernet interface assigned to a container. Confirm the IP addresses with the command:
~~~bash
$ docker inspect mongoDB
~~~
Notice the Networks section of the response:
~~~json
    "Networks": {
        "mongo-network": {
            "IPAMConfig": null,
            "Links": null,
            "Aliases": [
                "5010babf9a8d"
            ],
            "NetworkID": "b2743273da17e22e0137e94ca2571f9fcc11a61ed433a1714c734071fbe585d7",
            "EndpointID": "6bbd0907ca24aab5be8bbc93559782d35c04ae5566155d0116e4edd569061cd6",
            "Gateway": "172.18.0.1",
            "IPAddress": "172.18.0.2",
            "IPPrefixLen": 16,
            "IPv6Gateway": "",
            "GlobalIPv6Address": "",
            "GlobalIPv6PrefixLen": 0,
            "MacAddress": "02:42:ac:12:00:02",
            "DriverOpts": null
        }
    }
~~~
### Simple Web App.

Clone this repository:
~~~bash
$ git clone 
~~~
This application is a simple server-side rendering web app for updating the user-account database managed by our MongoDB server. It is not dockerized for now; we will do that in a later lab. Import the project into VS Code, open an integrated terminal and type the commands:
~~~bash
$ npm  install
$ cd app
$ node server.js
~~~
Open a new web browser tab at http://localhost:3000/. Click the Add/Edit Profile button. In the web form, enter your name, email address, and list of interests, and then click the Update Profile button. This sequence should result in the web app __writing a record to a table named users in our user-account database__. We can use the Mongo Express application to confirm this. Switch to the browser tab that shows the Mongo Express application, click the View button beside the `user-account` database, and click the View button beside the `users` collection name (A collection in Mongo is similar to a table in relational database). The page shows the details of the user profile you entered on the web form. Therefore, there are two lines of communication working in this setup:

+ Simple Web app to MongoDB container - This is over the regular localhost network managed by the host computer's operating system. The app is using the host's port 27017, which is mapper to the Mongo container's port 27017. 
+ Mongo Express container to MongoDB container - This is via the Docker-managed network we created - mongo-network.


In future labs, we will use this web app to demonstrate other aspects of the Docker platform and other topics. For convenience
, we will refer to it as the __User Profile Web App__.


[mongov]: https://hub.docker.com/_/mongo